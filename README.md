# si-stroki
Си-строки
В прошлом уроке мы разобрали динамические String-строки в реализации Arduino, а сейчас настало время стандартных статических строк языка C/C++. Такая строка представляет собой массив символов типа char (char array) и для неё работает такой же синтаксис, как и для остальных массивов (урок про массивы). Конец строки определяется нулевым символом \0 (или целым число 0), за это такой тип строк называют null-terminated string: ноль на конце позволяет программе определять конец строки и её длину. Также это стандартные строки языка Си и поэтому называются cstring.



Оптимизация компилятором
Компилятор оптимизирует строковые константы, но не во всех случаях. Если создать несколько строк как массивы (которые можно изменять) и присвоить им одинаковые строки, то они займут место в памяти как разные строки, т.е. столько, сколько в них суммарно символов:


Перенос строк (в программе)
Длинную строку можно переносить для удобства чтения и редактирования программы. Есть два способа:

Первый способ - работает как сложение строк в предыдущей главе. Каждая строка в своих кавычках пишется с новой строки:
Примечание: результирующий текст в переменной str в обоих случаях не имеет переносов, то есть в обоих примерах получится строка "Hello, World!".

Перенос строк (текст)
Для человека текст с новой строки - это текст с новой строки. Чтобы перенести текст на новую строку, мы нажимаем на клавишу Enter на клавиатуре. В то же время текст в текстовых файлах не хранится в разных "строках", он лежит в памяти одной длинной строкой. Когда мы открываем файл, компьютер читает текст и ищет в нём специальные невидимые символы, которые называются управляющими символами. Одним из таких символов является перенос строки - \n, именно его добавляет клавиша Enter. Чтобы компьютер при выводе строки перенёс её - нужно добавить этот символ в текст. В программе мы будем видеть этот символ, а вот в результирующем тексте он автоматически превратится в перенос строки. Примеры (без переноса в программе и с переносом двумя способами):

“Сырые” строки
"Сырые" строки - очень удобный инструмент компилятора, позволяющий задать любой текст просто в виде текста, включая кавычки и переносы строк без дополнительного экранирования. Синтаксис следующий R"(ваш текст)" или R"метка(ваш текст)метка", где метка - любой текст длиной до 16 символов без пробелов, должен быть одинаковым в начале и конце. Нужна для того, чтобы компилятор мог корректно определить конец сырой строки, если внутри самой строки есть )". Например строка R"(<tag onclick="func()" class="b1">)" приведёт к ошибке, т.к. компилятор решит что она закончилась после слова func! Добавим метку R"raw(<tag onclick="func()" class="b1">)raw" и компилятор без ошибки найдёт конец сырой вставки.
птимизация памяти
Как я писал выше - "текст в кавычках" хранится и в памяти программы, и в оперативной памяти, то есть после запуска микроконтроллера строка загружается в оперативную память, и уже там мы имеем к ней доступ. Как правило, объём программной памяти микроконтроллера в несколько раз больше, чем оперативной. Есть несколько возможностей хранения строк только в программной памяти, об этом очень подробно поговорим в уроке про PROGMEM.

Инструменты для Си-строк
Массивы символов не так просты, как кажутся: их возможности сильно расширяет стандартная библиотека cstring. Использование всех доступных фишек по работе с массивами символов позволяет полностью избавить свой код от тяжёлых String-строк и сделать его легче, быстрее и оптимальнее. Подробно обо всех инструментах можно почитать в официальной документации. Очень интересный пример с манипуляцией этими инструментами можно посмотреть здесь. А мы вкратце рассмотрим самые полезные.

Внимание! Функции конвертирования, работающие с типом float, являются очень тяжёлыми: их "подключение" занимает ~2 кБ Flash памяти!! Максимально избегайте их применения в крупном проекте. Для преобразования можно сделать свою функцию, практически готовые варианты для всех типов данных можно найти в стандартной ардуиновской Print.cpp (ссылка на файл на гитхабе Arduino).

абота с байтовым буфером
Очень часто в реальных задачах встречается ситуация, когда текстовые данные приходят в виде массива byte: по какому-нибудь каналу связи (MQTT, UDP, Bluetooth...), при чтении из файлов и так далее. Например приём по MQTT во многих библиотеках выглядит так:

void callback(byte* payload, uint16_t len) {
}
Пришёл поток байтов известной длины. Что с ними делать, если это текст и нам в программе он нужен как строка? Во многих примерах в Интернете предлагают преобразовать данные в String, просто как String s = (char*)payload. Делать так категорически нельзя, если переданный текст не оканчивается нулевым символом, а в большинстве случаев это как раз так. Дело в том, что свободная оперативная память во время работы микроконтроллера содержит не нули, а фактически случайные значения, оставшиеся от выгруженных переменных в разных местах программы. И если у нас приходит массив, который не оканчивается нулём, то в памяти после него тоже не обязан быть ноль, и при преобразовании в строку пойдёт вся память по порядку, пока не встретится ноль. Простой пример:

Через String
Если нужна String-строка, то нужно её создать, зарезервировать место под текст (чтобы избежать лишних аллокаций) и переписать в неё данные. К сожалению в реализации Arduino функция для переписывания массива в строку сделана приватной, поэтому придётся просто прибавить данные в цикле. Этот способ делает в два раза больше действий, чем могло бы быть, но для String-строки это единственный способ:

Прочее
Инструменты для копирования, поиска и сравнения

strcpy(str1, str2)
Копирует str2 в str1, включая NULL. Так как мы передаём указатель, цель и место назначения можно "подвинуть":

char str1[] = "hello world";
char str2[] = "goodbye";
// вставим bye после hello
strcpy(str1 + 6, str2 + 4); 
// тут str1 == hello bye
strncpy(str1, str2, num)
Копирует num символов из начала str2 в начало str1

char str1[] = "hello world";
char str2[] = "goodbye";
// вставим good после hello
strncpy(str1 + 6, str2, 4); 
// тут str1 == hello goodd
// вторая d осталась после "world"
strcat(str1, str2)
Прибавляет str2 к str1, при этом str1 должна иметь достаточный для этого размер. NULL первой строки заменяется на первый символ из str2
char str1[15] = "hello ";
char str2[] = "world";
strcat(str1, str2);
// здесь str1 - "hello world"
strncat(str1, str2, num)
Добавляет num символов из начала str2 к концу str1
strcmp(str1, str2)
Сравнивает str1 и str2. Возвращает 0, если строки одинаковы. Больше нуля, если str1 > str2. Меньше нуля, если str1 < str2.
strncmp(str1, str2, num)
Сравнивает первые num символов из строк str1 и str2. Возвращает 0, если эти участки одинаковы.
strchr(str, symb)
Ищет символ symb в строке str и возвращает указатель на первое совпадение.
strrchr(str, symb)
Ищет символ symb в строке str и возвращает указатель на последнее совпадение.
strcspn(str1, str2)
Выполняет поиск первого вхождения в строку str1 любого из символов строки str2 и возвращает количество символов до найденного первого вхождения.
strpbrk(str1, str2)
Выполняет поиск первого вхождения в строку str1 любого из символов строки str2 и возвращает указатель на найденный символ.
strspn(str1, str2)
Поиск символов строки str2 в строке str1. Возвращает длину начального участка строки str1, который состоит только из символов строки str2.
strstr(str1, str2)
Функция ищет первое вхождение подстроки str2 в строке str1.
strtok(str, delim)
Ищет символы-разделители delim в строке str, возвращает указатель на последний найденный. Как использовать - смотри тут.
strlen(str)
Возвращает длину строки str без учёта нулевого символа.
strdup(str)
Дублирует указанную str строку, динамически выделяя память под новую строку, возвращает указатель на новую строку. Внимание! Новая строка будет в динамической памяти, чтобы удалить такую строку - нужно использовать оператор delete или free.
Библиотека
У меня есть библиотека для удобной работы с Си-строками, по возможностям схожая со String, но гораздо легче и эффективнее. Библиотека называется mString, документацию и примеры смотрите на GitHub.

